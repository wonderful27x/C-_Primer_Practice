//=================message folder应用程序===================
//为什么要学习这个程序？
//C++ Primer经典范例，主要教会我们如何在c++程序中正确的使用拷贝控制，
//拷贝控制是c++比较难的点，但是c++程序总会隐式或显示的使用拷贝控制，
//不掌握拷贝控制通常在程序隐式发生拷贝操作时发生令我们无法理解的错误，
//另一方面正确运用拷贝控制往往给程序带来性能提升，所以拷贝控制是难点也是重点

//程序涵盖的知识点:
//	默认构造函数，默认实参,默认构造函数调用时机
//	拷贝控制成员
//	拷贝构造函数,拷贝构造函数调用时机
//	拷贝赋值运算符
//	移动构造函数
//	移动赋值运算符
//	析构函数,析构函数调用时机
//	拷贝控制成员的作用
//	三五法则，什么时候应该定义拷贝控制成员
//	拷贝成员的合成版本规则(普通类和继承体系)
//	被删除的合成拷贝成员规则(普通类和继承体系)
//	移动成员的合成版本规则(普通类和继承体系)
//	被删除的合成移动成员规则(普通类和继承体系)
//	析构函数组织移动操作规则(普通类和继承体系)
//	=default、=delete
//	右值引用
//	std::move
//	拷贝成员参数的const
//	swap
//	using指示和using声明，扩展的重载函数集
//	移动操作保证移后源的安全析构
//	拷贝构造函数，拷贝赋值运算符和析构函数所做的工作
//	移动操作于noexcept
//	赋值运算符的自赋值情况
//	delete,delete 非动态分配的内存，多次delete


//程序简介:
//程序有两个类Message和Folder
//Message代表一个消息，Folder代表消息的目录
//一个Message可以出现在多个Folder中，它拥有一个保存Folder指针的set
//一个Folder包含多个Message,也有一个set保存Message指针


#ifndef FOLDER_H
#define FOLDER_H

#include <string>
#include <set>

//声明class，因为Message在其定义前需要使用其类名
//参见名字查找page 254
class Folder;

class Message {
	friend void swap(Message &, Message &);
	friend class Folder;
public:
	//构造函数，初始值列表初始化消息内容
	//set被默认初始化为空的
	//默认实参
	//调用时可省略该实参，使用的就是"",因此它也属于默认构造函数
	//多次声明同一个函数是合法的，但是给定作用域一个形参只能被赋予一次默认实参，参考page 212
	//局部变量不能作为默认实参，但是类型能转换的表达式可以
	//explicit禁止隐式调用
	explicit Message(const std::string &str="") : 
		contents(str) {}

	//拷贝控制成员:
	//1.拷贝构造函数
	//2.拷贝赋值运算符
	//3.移动构造函数
	//4.移动赋值运算符
	//5.析构函数
	//三五法则:
	//一个类如果定义了任何一个拷贝操作，就应该定义其他五个
	//作用:
	//拷贝和移动构造函数定义当用一个同类型的对象初始化另一个对象时做什么
	//拷贝和移动赋值运算符定义将一个同类型对象赋予另一个时做什么
	
	//==================拷贝构造函数，拷贝赋值运算符，析构函数==============================	
	//拷贝构造函数:
	//第一个参数是自身类型const引用,额外参数都有默认值,
	//参数必须是引用但可以不是const,const的好处是可以接受右值
	//拷贝构造函数在一些情况被隐式使用，因此通常是非explicit的
	
	//合成的拷贝构造函数
	//为定义自己的编译器将为我们定义一个合成的拷贝构造函数
	//合成的拷贝构造函数将参数非static成员逐个拷贝到正在创建的对象中
	//对于类类型又会调用其拷贝构造函数，内置类型直接拷贝
	
	//拷贝构造函数调用时机:
	//1.使用=定义变量(初始化)
	//2.将一个对象作为实参传递给一个非引用类型的形参
	//3.从一个返回类型为非引用类型的函数返回一个对象
	//4.用花括号列表初始化一个数组中的元素或一个聚合类中的成员
	
	//拷贝赋值运算符
	//为定义自己的编译器也会为我们定义一个合成的拷贝赋值运算符
	//合成的拷贝赋值运算符赋值规则与拷贝构造函数类似
	
	//析构函数
	//当未定义自己的编译器会为我们定义一个合成的析构函数，
	//合成的析构函数的函数体是空的
	//析构函数执行与构造函数相反的操作,page 445
	//构造函数用于创建和初始化资源，先初始化再执行函数体,初始化顺序按照类中定义的顺序
	//析构函数用于释放资源，先执行函数体再隐式销毁成员(指针类型不会调用delete),
	//销毁顺序按照初始化顺序逆序执行,类类型将调用其析构函数，内置类型什么也不做
	//派生类析构函数只负责销毁派生类自己分配的资源
	//派生类析构函数首先调用，然后是基类析构函数，沿着继承体系反方向类推
	
	//对象被销毁析构函数被调用，析构函数调用时机:
	//1.变量离开作用域
	//2.一个对象被销毁时，其成员被销毁
	//3.容器被销毁时，其元素被销毁
	//4.动态分配对象指针调用delete
	//5.创建临时对象的完整表达式结束时
	
	//default
	//默认构造函数、拷贝控制成员定义为=defalut显示要求编译器生成合成的版本
	//默认构造函数的调用时机:page 262
	
	//delete
	//任何函数定义为=delete表示一个删除的函数
	//定义为删除的函数不能以任何方式使用他们
	//删除了析构函数的类型不能定义此变量成员，但是可以动态分配，不能释放对象
	//删除拷贝构造函数和拷贝赋值运算符将阻止拷贝
	
	//默认构造函数、拷贝构造函数、拷贝赋值运算符、析构函数，在没有定义时编译器都会生成合成的版本
	//这些合成的版本有可能被定义为删除的函数，而这间接影响了他们能够执行的操作，
	//因此合成成员被删除的规则也很重要，具体page 450
	
	//===============================移动构造函数，移动赋值运算符========================
	//右值引用&&
	//右值引用和左值引用一样，仅仅是另外一个名字
	//右值引用只能绑定到有值表达式
	//左值引用只能绑定到左值表达式，const的左值引用可以绑定到右值表达式
	//变量都是左值，右值引用变量也是左值,比如
	//int &&rr1 = 42;
	//int &&rr2 = rr1; 错误，rr1是左值
	//std::move告诉编译器我们有一个左值，希望像右值一样处理它，因此
	//int &&rr3 = std::move(rr1);//正确
	//但是必须注意这杨做意味着:
	//!!!我们承诺除了对rr1赋值或销毁(析构)它外，我们不能再使用它的值
	//我们必须理解，std::move本身并没有对rr1的值做任何改变,这仅仅是一种承诺，
	//而有了这种承诺,那么程序就可以对rr1实现移动语义，假如rr1是指针类型，
	//那我们就可让我们的一个指针获取它的值，然后让rr1=nullptr,这样就实现了移动语义，
	//!!!注意这时我们必须保证移后源是可析构的
	//之后对rr1解引用是错误的，但是没关系我们已经承诺不会这样做了，而对rr1重新赋值，或delete都是正确的
	
	//移动构造函数
	//移动构造函数的第一个参数是自身类型的非const右值引用，额外参数都有默认值
	//因为通常需要窃取(修改)参数以达到移动语义,所以是非const的
	//移动构造函数和移动赋值运算符通常不应该抛出异常 noexcept,原因page 474
	
	//合成的移动操作
	//如果定义了任何一个拷贝构造函数、拷贝赋值运算符、析构函数，编译器就不会生成合成的移动操作
	//只有当类没有定义它们中的任何一个并且类的每个非static成员都是可以移动的，编译器才会合成
	//当我们使用=defalut显示要求编译器生成合成的版本而编译器又不能移动所有成员时移动操作将会定义为删除的
	//因为删除的函数不能被调用，因此合成的移动操作被删除的规则也很重要，page 476
	//注意和上面拷贝的区别
	//拷贝:不定义我就合成，合成了但有可能是删除的
	//移动:不定义拷贝且都能移动我才合成，否则我不合成，如果用=default强制我合成但又不都能移动，我就删除它
	//如果定义了移动操作则合成的拷贝构造函数和拷贝赋值运算符被定义为删除的
	
	//移动构造函数和拷贝构造函数遵循普通函数匹配规则
	//如果没有移动操作，右值也被拷贝(注意前提是有const)
	//如Foo(const Foo&)
	//Foo x;
	//Foo y(std::move(x))
	//原理是const的左值引用可以绑定到有值
	Message(const Message &);
	Message &operator=(const Message &);
	Message(Message &&);
	Message &operator=(Message &&);
	~Message();

	//从给定Folder集合中添加或删除
	void save(Folder &);
	void remove(Folder &);
	void debug_print();
private:
	//delete 只能对动态分配的对象指针使用，多次delete相同的指针将发生错误，但delete nullptr的指针是允许的
	//容器保存指针类型，在销毁或删除元素时都不会对指针进行delete,需要我们收到销毁
	//上面的规则结合起来就很好理解了，因为容器保存的可能不是动态对象的指针，当然不能使用delete
	//在本应用程序中就是非动态对象的指针
	std::string contents;                //消息内容
	std::set<Folder *>folders;           //消息所在的Folder

	void add_to_Folders(const Message &);//向folder添加一个消息
	void remove_from_Folders();          //从folder中移除消息
	void move_Folders(Message *);        //移动消息

	void addFldr(Folder *f) { folders.insert(f); }
	void remFldr(Folder *f) { folders.erase(f); }
};

//定义自己版本的swap函数,标准库中的swap通常都是拷贝，
//定义自己版本的swap避免拷贝
void swap(Message &, Message &);


//Folder类，表示Message的目录
class Folder {
	friend void swap(Message &, Message &);
	friend class Message;
public:
	//合成版本的默认构造函数,注意我们定义了其他构造函数，如果不定义默认构造函数编译器将不会合成默认构造函数
	//如Message，使用=default显示要求编译器定义合成版本的默认构造函数
	//这条规则对拷贝控制成员无效
	Folder() = default;
	//拷贝控制成员
	Folder(const Folder &);
	Folder &operator=(const Folder &);
	Folder(Folder &&);
	Folder &operator=(Folder &&);
	~Folder();

	//将给定Message从Foler中添加或删除
	void save(Message &);
	void remove(Message &);
	void debug_print();
private:
	std::set<Message *> msgs;

	void add_to_Messages(const Folder &);
	void remove_from_Msgs();
	void addMsg(Message *m) { msgs.insert(m); }
	void remMsg(Message *m) { msgs.erase(m); }
	void move_Messages(Folder *);
};

#endif
